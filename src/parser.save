/*
   Parser des commandes en provenance du port série
*/
#include "parser.h"
#include <Arduino.h>
#include <stdlib.h>
#include <EEPROMex.h>





#define __DEBUG1__ false
#if __DEBUG1__
    #define PRINT Serial.println
#else
    #define PRINT Serial.print
#endif


#define __DEBUG2__ false
#if __DEBUG2__
    #define ECHO echo(cmd, vparm);
#else
    #define ECHO ;
#endif




bool debug = false;
int TempCoefficientRaw = 1;
int TempCoefficient = 1;
int MaxSteps = 0;
bool MoonliteMode = false;
#define MAXCOMMAND  8
char    cmd[MAXCOMMAND];
char    parm[MAXCOMMAND];
char    packet[MAXCOMMAND];
char    outWire[MAXCOMMAND];
char    tempString[32];
//static uint16_t waitvalue[5]= {1580, 1053, 702, 468, 312};
static uint16_t waitvalue[5]= {1600, 800, 400, 200, 100};

long hexstr2long(char *line);

AbsoluteDriver *driver = NULL;
long currentPos = 0;
long targetPos = 0;
long previousPos = 0;
long togo = 0;
int direction = FORWARD;
int stepMode = 0;
int speedNumber = 1;
int speed = 2;
int back = 0;
bool moving = false;
int backlash = 0;
int wait = waitvalue[0];
///////////////////////////
// Communications
///////////////////////////
boolean ArduHandle = false;
bool wireRequest = false;
int I2C_ClearBus();
void requestEvent();
void receiveEvent(int howmany);
bool streamlock = false;
#define RELEASED    false
#define LOCK        true

// EEProm read/write
int addressCurrentPos;
const int memBase          = 350;

long int vparm = 0;
bool    interrupt = true;


extern const byte interruptPIN;

// déclaration de fonctions
//long hexstr2long(char *line);
//void process_data (const char * input);

void echo(const char* cmd, int parm)
{
    char s[32];
    sprintf(s,"%s:%u",cmd,parm);
    Serial.println(s);
}

void move()
{
  if (!interrupt)
  {
    if (togo > 0)
    {
      driver->move(direction, wait);
      currentPos += direction;
      togo--;
    }
    else
    {
      interrupt = true;
    }
  }
  else
  {

    if((digitalRead(INWARD) == LOW) && (digitalRead(OUTWARD) == LOW))
    {
      speedNumber = 1+(speedNumber+1) % 5;
      Serial.println(speedNumber);
      delay(1000);
    }    
    else if(digitalRead(INWARD) == LOW)
    {
      if (currentPos > 0)
      {
        interrupt = false;
        direction = -1;
        togo = 1;
        wait = waitvalue[0];
      }
    }
    else if(digitalRead(OUTWARD) == LOW)
    {
      interrupt = false;
      direction = +1;
      togo = 1;
      wait = waitvalue[0];
    }
  } 
}

void stop()
{
    interrupt = true;
}

void go()
{
  interrupt = false;
}

void storePos() // save pos if it has changed or each minute
{
  if (currentPos != previousPos)
  {
    EEPROM.writeLong(addressCurrentPos,currentPos);
  }
}


void initialize(int initPos)
{
  Serial.begin(SERIAL_SPEED);
  while(!Serial);
  driver = new AbsoluteDriver(STEPS_REV, DRIVER_DIR, DRIVER_STEP, DRIVER_EN, M0, M1, M2);
  driver->setSpeedProfile(BasicStepperDriver::CONSTANT_SPEED, MOTOR_ACCEL, MOTOR_ACCEL);
  currentPos      = initPos;
  targetPos       = initPos;
  previousPos     = initPos;
  direction       = FORWARD;
  togo            = 0;
  stepMode        = 0;
  pinMode(INWARD, INPUT_PULLUP);
  pinMode(OUTWARD, INPUT_PULLUP);
  #if defined(ARDUINO_AVR_NANO)
    pinMode(M0, OUTPUT);
    pinMode(M1, OUTPUT);
    pinMode(M2, OUTPUT);
    digitalWrite(M0, LOW);
    digitalWrite(M1, LOW);
    digitalWrite(M2, HIGH);
  #endif
  EEPROM.setMemPool(memBase, EEPROMSizeUno);
  addressCurrentPos      = EEPROM.getAddress(sizeof(long));
  currentPos = EEPROM.readLong(addressCurrentPos);
}


void process_data (const char * input)
{
    memset(tempString,'\0',sizeof(tempString));
    //parse de la commande
    int len = strlen(input);
    if (len == 1)
    {
        cmd[0] = input[0];
        cmd[1] = '\0';
    }
    else
    {
        if (len > 2)
        {
            memset(parm,0,MAXCOMMAND);
            strncpy(parm, input + 2, len - 2);
            vparm =  hexstr2long(parm);
        }
        cmd[0] = input[0];
        cmd[1] = input[1];
        cmd[2] = '\0';
    }
 
  // for now just display it
  // (but you could compare it to some value, convert to an integer, etc.)
  //Serial.print (cmd);  // end of process_data
      // toggle debug on/off

    if (!strcasecmp(cmd, "D"))
    {
        debug = !debug;
        if(debug)
        {
            Serial.println("Debug enabled");
        }
    }

    if (!strcasecmp(cmd, "GP"))
    {
        sprintf(tempString, "%lX#", currentPos);
        if (wireRequest) strcpy(outWire, tempString);
        if (__DEBUG1__) Serial.println(currentPos);
        PRINT(tempString);
        //PRINT("#");
     }

    if (!strcasecmp(cmd, "GC")) {
        sprintf(tempString, "%02X#", TempCoefficientRaw);
        PRINT(tempString);
//        PRINT("#");
    }

    if (!strcasecmp(cmd, "GV")) {
        PRINT("10#");
    }

    if (!strcasecmp(cmd, "GH"))
    {
        sprintf(tempString,"%02X", stepMode);
        PRINT(tempString);
        PRINT('#');
    }

        // get temperature
    if (!strcasecmp(cmd, "GT")) {
    /*
      // Skip temperature reading when motor is running
      if (stepper.isMoving()) {
        if (TempSensor_Present)
          TempSensor_Reading = DHT_getTemperature();
      }

      // reset temp sensor read timer.
      millisLastTempSensorRead = millis();

      //char tempString[6];
      if (MoonliteMode)
        // compatability mode, 0.5 degeee resolution
        sprintf(tempString, "%04X", (int)(TempSensor_Reading/0.5));
      // else 0.125 degree resolution
      else sprintf(tempString, "%04X", (int)(TempSensor_Reading/0.125));
      PRINT(tempString);
      PRINT("#");
    */
        sprintf(tempString, "%02X", 20);
        PRINT(tempString);
        PRINT("#");
    }
    
    // retourner nouvelle position
    if (!strcasecmp(cmd, "GN")) {
        sprintf(tempString, "%lX#", targetPos);
        if (wireRequest) strcpy(outWire, tempString);
        PRINT(tempString);
    }

    // Le focuser se déplace - 01 se déplace, 00 sinon
    if (!strcasecmp(cmd, "GI")) {
      if (!interrupt) {
        PRINT("01#");
      }
      else {
        PRINT("00#");
      }
    }

    // retourne la vitesse du moteur, seules valeurs possible 02, 04, 08, 10, 20, définies par la commande SD
    if (!strcasecmp(cmd, "GD")) {
        sprintf(tempString, "%02X#", 2<<(speedNumber-1));
        PRINT(tempString);
    }

    // Version du firmware "10"
    if (!strcasecmp(cmd, "GV")) {
      PRINT("10#");
    }

        //Coefficient de temperature
    if (!strcasecmp(cmd, "SC")) {
      TempCoefficientRaw = vparm;
      // covert signed 8-bit to signed int
      if ((TempCoefficientRaw & 0x80)) {// negtive
        TempCoefficient = TempCoefficientRaw - 256;
      }
      else {
        TempCoefficient = TempCoefficientRaw;
      }
    }

    // full step mode
    if (!strcasecmp(cmd, "SF")) {
        stepMode = 0;
    }

    // half step mode
    if (!strcasecmp(cmd, "SH")) {
        stepMode = 1;
    }

    // mode de compatibilité
    if (!strcasecmp(cmd, "YM")) {
      MoonliteMode = false;
    }

    if (!strcasecmp(cmd, "FQ")) {
        stop();
    }


    if (!strcasecmp(cmd, "FG")) {
      go();
     }


    // Commandes envoyées par la raquette
    if (!strcasecmp(cmd, "FI")) // move inward
    {
      PRINT(cmd);
    }
    if (!strcasecmp(cmd, "FO")) // move forward
    {
      PRINT(cmd);
    }






    // fixer la vitess, seules valeurs acceptables 02, 04, 08, 10, 20
    if (!strcasecmp(cmd, "SD"))
    {
        speedNumber = log(vparm)/log(2);
        wait = waitvalue[speedNumber-1]

        //long rpm = MIN_RPM + (vspeed - 1) * (MIN_RPM - MIN_RPM) / 5;
        //driver->setRPM(1);

        ECHO
    }

    // initialiser la position
    if (!strcasecmp(cmd, "SP")) {
        currentPos = vparm;
        EEPROM.writeLong(addressCurrentPos,currentPos);
    }

    // fixer la nouvelle position
    if (!strcasecmp(cmd, "SN"))
    {
        targetPos = vparm;
        togo = abs(targetPos - currentPos);
        if (targetPos > currentPos)
            direction = +1; // FORWARD
        else
            direction = -1; // INWARD 
        wait = waitvalue[speedNumber-1];
    }

    // enable TempComp
    if (!strcasecmp (cmd, "Y+"))
    {
    /*  TempCompEn = true;

      // Latch current position and average temperature.
      TempCompOriginalTemperature = TempSensor_Average;
      TempCompOriginalPosition = stepper.currentPosition();

      TempCompLastTemperature = TempSensor_Average;
      TempCompTargetPosition = TempCompOriginalPosition;
    */}

        // disable TempComp, currently not used
    if (!strcasecmp (cmd, "Y-")) {
      //TempCompEn = false;
    }

    if (!strcasecmp(cmd, "Z+")) {
    /*  if (TempCompEn) {
        PRINT("01#");
      }
      else {
        PRINT("00#");
      }
    */
    }

    // home the motor, hard-coded, ignore parameters since we only have one motor
    if (!strcasecmp(cmd, "PH")) {
      targetPos = 8000;
      interrupt = false;
    }

    // set backlash
    if (!strcasecmp(cmd, "YB")) {
      backlash = vparm;
    }

    // get backlash set by YB
    if (!strcasecmp(cmd, "ZB")) {
      //char tempString[6];
      sprintf(tempString, "%02X", backlash);
      PRINT(tempString);
      PRINT("#");
    }

    // set TempComp threshold in unit of 0.25 degree
    if (!strcasecmp(cmd, "YT")) {
    /*
      TempCompThresholdRaw = hexstr2long(param);
      TempCompThreshold = (float)TempCompThresholdRaw / 4; // covert to degree
    */
    }

    // get TempComp threshold set by YT
    if (!strcasecmp(cmd, "ZT")) {
    /*
      //char tempString[6];
      sprintf(tempString, "%02X", TempCompThresholdRaw);
      PRINT(tempString);
      PRINT("#");
    */
    }

    if (!strcasecmp(cmd, "YX")) {
    
      MaxSteps = vparm;
    
    }

    if (!strcasecmp(cmd, "ZX")) {
      //char tempString[6];
      sprintf(tempString, "%04X", MaxSteps);
      PRINT(tempString);
      PRINT("#");
    }

    if (!strcasecmp(cmd, "ZA")) {
    /*
      int TempInt;
      TempInt = (int)(TempSensor_Average * 100);
      if (TempInt >= 0) {
        TempInt = TempInt & 0xFFFF;
      }
      else { // convert to 2's complement
        TempInt = ~abs(TempInt) & 0xFFFF;
      }

      //char tempString[6];
      sprintf(tempString, "%04X", TempInt);
      PRINT(tempString);
      PRINT("#");
    */
    }

    // Debug Info
//    if (!strcasecmp(cmd, "SS"))
//      if(debug) outputDebugInfo();




}

long hexstr2long(char *line) {
  long ret = 0;

  ret = strtol(line, NULL, 16);
  return (ret);
}

void processIncomingByte (const byte inByte)
{
  static char input_line [MAXCOMMAND];
  static unsigned int input_pos = 0;

  streamlock = LOCK;

  switch (inByte)
  {
  case ':':
      input_pos = 0;
      break;
  case '#':   // end of text
      input_line [input_pos] = 0;  // terminating null byte
      // terminator reached! process input_line here ...
      process_data (input_line);
      streamlock = RELEASED;
      // reset buffer for next time
      //input_pos = 0;  
      break;
  case '\r':   // discard carriage return
      break;
  case '\n':   // discard carriage return
      break;
  default:
      // keep adding if not full ... allow for terminating null byte
      if (input_pos < (MAXCOMMAND - 1))
        input_line [input_pos++] = inByte;
      break;
  }  // end of switch
   
} // end of processIncomingByte  
